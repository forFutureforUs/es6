<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
        /**
         * 1、二进制和八进制表示法
         * ES6提供了二进制和八进制数值的新的写法，分别用前缀0b(或0B)和0o(或0O)表示
        */   
        {
            console.log(0b111110111 === 503);
            console.log(0o767 === 503);
        } 
        /**
         * 从ES5开始，在严格模式下，八进制就不再允许使用前缀0表示，ES6进一步明确，要使用0o表示
        */
       {
           // 非严格模式
           (function () {
               console.log(0o11 === 011);
           })()

           //严格模式
        //    (function() {
        //        'use Strict';
        //        console.log(0o11 === 011);
        //    })()
       }
       // 如果要将0b和0o前缀的字符串数值转为十进制，要使用Number方法。
       {
           console.log(Number('0b111'));
           console.log(Number('0o10'));
       }
    </script>

    <script>
        /**
         * Number.isFinite(),Number.isNaN()
         * ES6在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法
         * Number.isFinite()用来检查一个一个数值是否为有限，即是不是Infinity
        */
       {
           console.log(Number.isFinite(15));
           console.log(Number.isFinite(0.8));
           console.log(Number.isFinite(NaN));
           console.log(Number.isFinite(Infinity));
           console.log(Number.isFinite(-Infinity));
           console.log(Number.isFinite('foo'));
           console.log(Number.isFinite('15'));
           console.log(Number.isFinite(true));
       }
       /**
        * 注意，如果参数类型不是数值，Number.isFinite一律返回false
        * Number.isNaN()用来检查一个值是否为NaN
       */
      {
          console.log(Number.isNaN(NaN));
          console.log(Number.isNaN(15));
          console.log(Number.isNaN('15'));
          console.log(Number.isNaN(true));
          console.log(Number.isNaN(9/NaN));
          console.log(Number.isNaN('true'/0));
          console.log(Number.isNaN('true'/'true'));
      }
      /**
       * 如果参数类型不是NaN,Number.NaN一律返回false
       * 
       * 他们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()
       * 将非数值的值转为数值，在进行判断，而这两个新方法只对数值有效，Number.isFinite()
       * 对非数值一律返回false,Number.isNaN()只对NaN才返回true,非NaN一律返回false
      */
     {
         console.log('---------------------------')
         console.log(isFinite(25));
         console.log(isFinite('25'));
         console.log(Number.isFinite(25));
         console.log(Number.isFinite('25'));

         console.log(isNaN(NaN));
         console.log(isNaN('NaN'));
         console.log(Number.isNaN(NaN));
         console.log(Number.isNaN('NaN'));
         console.log(Number.isNaN(1));
     }
    </script>

    <script>
        /**
         * 3、Number.parseInt()、Number.parseFloat()
         * ES6将全局变量parseInt() 和 parseInt(),移植到Number对象上面，行为完全保持不变
        */
        {
            // ES5的写法
            console.log(parseInt('12.34'));
            console.log(parseFloat('123.45#'));

            // ES6的写法
            console.log(Number.parseInt('12.34'));
            console.log(Number.parseFloat('12.34#'));
        }
        // 这样做的目的，是逐步减少全局性方法，使得语言逐步模块化
        {
            console.log(Number.parseInt === parseInt);
            console.log(Number.parseFloat === parseFloat);
        }
    </script>

    <script>
        /**
         * 4、Number.isInteger()
         * Number.isInteger() 用来判断一个数值是否为整数
        */
       {
           console.log(Number.isInteger(25));
           console.log(Number.isInteger(25.1));
       }
       /**
        * JavaScript内部，整数和浮点数采用的都是同样的储存方法，所以25和25.0
        * 被视为同一个值。
       */
       {
           console.log(Number.isInteger(25));
           console.log(Number.isInteger(25.0));
       }
       // 如果参数不是数值，Number.isInteger返回false
       {
           console.log(Number.isInteger());
           console.log(Number.isInteger(null));
           console.log(Number.isInteger('15'));
           console.log(Number.isInteger(true));
       }
       /**
        * 注意，由于JavaScript采用iEEE 754标准，数值存储为64为双精度格式，数值精度
        * 最多可以达到53个二进制位（1个隐藏位与52个有效位）。如果数值的精度超过这个限度
        * 第54位及以后就会被丢弃，这种情况下，Number.isInteger可能会误判。
       */
      {
          console.log(Number.isInteger(3.0000000000000002));
      }
      /**
       * 上面代码中，Number.isInteger的参数明明不是整数，但是会返回true.原因就是这个
       * 小数的精度达到了小数点后16个十进制位，转成二进制位超过了53个二进制，导致最后
       * 的那个2被丢弃了
       * 
       * 类似的情况还有，如果一个数值的绝对值小于Number.MIN_VALUE(5E-324),即小于
       * JavaScript能够分辨的最小值，会自动转为0，这时Number.isInteger也会误判
      */
      {
          console.log(Number.isInteger(5E-324));
          console.log(Number.isInteger(5E-325));
      }
      /**
       * 上面代码中，5E-325由于值太小，会自动转为0，因此返回true.
      */
    </script>

    <script>
        /**
         * 5、Number.EPSILON
         * ES6在Number对象上面，新增一个极小的常量Number.EPSILON，根据规格，他表示
         * 1与大于1的最小浮点之间的差。
         * 
         * 对于64位浮点数来说，大于1的最小浮点数相当于二进制的1.00...0001,小数点后面
         * 有连续51个零，这个值减去1之后，就等于2的-52次方
        */
       {
           console.log(Number.EPSILON === Math.pow(2,-52));
           console.log(Number.EPSILON);
           console.log(Number.EPSILON.toFixed(20));
       }
       /**
       * Number.EPSILON实际上是JavaScript能够表示的最小精度，误差如果如果小于这个值
       * 就可以认为已经没有意义了，即不存在误差。
       *
       * 引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数
       * 计算是不精确的。
       */
       {
           console.log(0.1 + 0.2);
           console.log((0.1+ 0.2 - 0.3).toFixed(20));

           // 上面代码解释了，为什么比较 0.1 + 0.2 与 0.3的道德结果是false
       }
    </script>
</body>
</html>