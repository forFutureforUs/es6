<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <div>111</div>
    <div>222</div>
    <div>333</div>
    <script>
        /**
         * 1、 扩展运算符 
         * 含义：
         *      扩展运算符(spread)是三个点（...）.它好比rest参数的逆运算，将一个
         * 数组转为用逗号分隔的参数列。
         */    
        {
            console.log(...[1,2,3]); // 1  2  3

            console.log(1,...[2,3,4],5)  // 

            console.log(...document.querySelectorAll('div'));
        }
        // 该运算符主要用于函数调用
        {
            function push(array,...items) {
                array.push(...items);
            }
            function add(x,y) {
                return x + y;
            }
            const numbers = [4,38];
            console.log(add(...numbers));

        }
        /**
         * 上面代码中，array.push(...items)和add(...numbers)这两行，都是函数调用
         * 他们的都使用了扩展运算符，该运算符将一个数组，变为参数序列。
         * 
         * 扩展运算符与正常的函数参数可以结合使用，非常灵活。
        */
        {
            function f(v,w,x,y,z) {
                return v+w+x+y+z;
            }
            const args = [0,1];
            console.log(f(-1,...args,2,...[3]));
        }
        // 扩展运算符后面还可以放置表达式
        {
            let x = 1;
            const arr = [...(x>0? ['a']: []),'b'];
            console.log(arr);
        }
        // 如果扩展运算符后面是一个空数组，则不产生任何效果。
        {
            console.log([...[],1]);
        }
        /**
         * 替代函数的apply方法
         * 由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的
         * 参数了
        */
       {
            // ES5写法
            function f(x,y,z) {

            }
            var args = [0,1,2];
            f.apply(null,args);

            function f1(a,b,c) {

            }
            let arg = [1,2,3];
            f1(...args);
       }
       /**
        * 下面是扩展运算符取代apply方法的一个实际的例子，应用Math,max方法，简化求出
        * 一个数组最大元素的写法
       */
      {
          // ES5的写法
          Math.max.apply(null,[3,6,8,1]);
          // ES6的写法
          Math.max(...[3,6,8,1]);
          // 等同于
          Math.max(14,3,77);
      }
      /**
       * 上面代码中，由于javaScript不提供求数组最大元素的函数，所以只能套用Math.max
       * 函数，将数组转为一个参数序列，然后求最大值，有了扩展运算符以后，就可以直接
       * 使用Math.max了
      */
     {
         //ES5的写法
         let arr1 = [0,1,2];
         let arr2 = [3,4,5];
         Array.prototype.push.apply(arr1,arr2);
         console.log(arr1,arr2);

         // ES6的写法
         let arr3 = [5,6,7];
         let arr4 = [6,7,8];
         arr3.push(...arr4);
         console.log(arr3,arr4);
     }
     /**
      * 上面代码的ES5写法中，push方法的参数不能是数组，所以只能通过apply方法
      * 变通使用push方法。有了扩展运算符，就可以直接将数组传入push方法。
      * 
      * 下面是另外一个例子
     */
    {
        // ES5
        new (Date.bind.apply(Date,[null,2015,1,1]))
        // ES6
        new Date(...[2015,1,1]);
    }
    /**
     * 扩展运算符的应用
     * （1）复制数组
     * 数组是复合数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆
     * 一个全新的数组。
    */
   {
       const a1 = [1,2];
       const a2 = a1;

       a2[0] = 2;
       console.log(a1); // [2,2]
   }
   /**
    * 上面代码中，a2并不是a1的克隆，而是指向同一份数据的另一个指针。修改a2,会
    * 直接导致a1的变化。
    * 
    * ES5只能变通方法来复制数组。
   */
  {
      const a1 = [1,2];
      const a2 = a1.concat();

      a2[0] = 2;
      console.log(a1);   // [1,2];
    }
    /**
     * 上面代码中，a1会返回原数组的克隆，在修改a2就不会对a1产生影响。
     * 
     * 扩展运算符提供了复制数组简便写法。
     */
    {
        const a1 = [1,2];
        // 写法一
        const a2 = [...a1];
        // 写法二
        const [...a3] = a1;
        console.log(a2,a3);
        a1[0] = 111;
        a2[0] = 222;
        a3[0] = 333;
        console.log(a1,a2,a3);
    }
    /**
     * 上面的两种写法，a2,a3都是a1的克隆
     * （2） 合并数组
     * 扩展运算符提供了数组合并的新写法
     */
    {
        const arr1 = ['a','b'];
        const arr2 = ['c'];
        const arr3 = ['d','e'];

        // ES5的合并数组
        console.log(arr1.concat(arr2,arr3));
        console.log(arr1,arr2,arr3);

        // ES6的合并数组
        console.log(...arr1,...arr2,...arr3);
    }
    // 不过，这两种方法都是浅拷贝，使用的时候需要注意
    {
        const a1 = [{foo: 1}];
        const a2 = [{bar: 2}];

        const a3 = a1.concat(a2);
        const a4 = [...a1,...a2];

        console.log(a3[0] === a1[0]);
        console.log(a4[0] === a1[0]);
    }
    /**
     * 上面代码中，a3和a4使用两种不同方法合并而成的新数组，但是他们的成员都是对
     * 原数组的引用，这就是浅拷贝，如果修改了原数组的成员，会同步反映到新数组
     * 
     * （3） 与解构赋值结合
     * 扩展运算符可以与解构赋值结合起来，用于生成数组
    */
   {
       // ES5
        const list = [1,2,3,4,5,7,6]
       let a = list[0], rest = list.slice(1)
       // ES6
       let [b,...last] = list;
       console.log(last);
   }
   // 下面是另外一个例子
   {
       const [first,...rest] = [1,2,3,4,5,6];
       console.log(first,rest);

       const [firstone,...restone] = [];
       console.log(firstone,restone); // undefined []

       const [firsttwo,...resttwo] = ['foo'];
       console.log(firsttwo,resttwo); // foo []
   }
   // 如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错
   {
       //const [...rest,last] = [1,2,3,4,5,6];

       //const [first,...medium,last] = [1,2,3,4,5,6]
   }
   /**
    * (4) 字符串
    * 
    * 扩展运算符还可以将字符串转为真正的数组
   */
    {
        console.log([...'hello']);
        console.log('hello'.split(''));
    }
    // 上面的写法，有一个重要的好处，那就是你能够正确识别四个字节的Unicode字符
    {
        console.log('x\uD83D\uDE80y'.length);
        console.log([...'x\uD83D\uDE80y'].length);
    }
    /**
    * 上面代码的第一种写法，JavaScript会将四个字节的Unicode字符，识别为两个字节
    * 采用扩展符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写
    */
    {
        function length(str) {
            return [...str].length;
        }
        console.log(length('x\uD83D\uDE80y'))
    }
    /**
    * 凡是涉及到操作四个字节的Unicode字符的函数，都有这个问题，因此，最好都用扩展运算符
    * 改写。
    */
    {
        let str = 'x\uD83D\uDE80y';
        console.log(str.split('').reverse().join(''));
        console.log([...str].reverse().join(''));
    }
    /**
    *  上面代码中，如果不用扩展运算符，字符串的reverse操作符就不正确。
    * (5) 实现了Iterator接口的对象
    * 任何Iterator接口的对象，都可以用扩展运算符转为真正的数组
    */ 
    {
        let nodeList = document.querySelectorAll('div');
        console.log(typeof nodeList);
        let arr = [...nodeList];
        console.log(arr);
    }
    /**
    * 上面代码中，querySelector方法返回的是一个nodeList对象，他不是数组，而是一个
    * 类似数组的对象，这时，扩展运算符可以将其转为真正的数组，原因就在于nodeList
    * 对象实现了iterator
    *
    * 对于那些没有部署Iterator接口的类似数组的对象，扩展运算符就无法将其转为真正的
    * 数组。
    */
    {
        let arrayLike = {
            '0': 'a',
            '1': 'b',
            '2': 'c'
        }
       // let arr = [...arrayLike] //TypeError: arrayLike is not iterable
    }
    /**
    * 上面代码中，arrayLike 是一个类似数组的对象，但是没有部署Iterator接口，扩展
    * 运算符就会报错。这时，可以改为使用Array.from方法将arrayLike转为真正的数组。
    *
    * (6) Map 和Set结构，Generator函数
    * 扩展运算符内部调用的是数据结构的Iterator接口，因此只要具有iterator接口的
    * 对象，都可以使用扩展运算符，比如Map结构。
    */
    {
        let map = new Map([
            [1,"one"],[2,"two"],[3,"three"]
        ])
        console.log(map.keys(),map.values());
        console.log([...map.keys()],[...map.values()]);
    }
    // Generator 函数运行后，返回一个遍历器对象，因此可以使用扩展运算符。
    {
        const go = function*() {
            yield 1;
            yield 2;
            yield 3;
        };
        console.log(...go());
    }
    /**
    * 上面代码中，变量go是一个Generator函数，执行后返回得是一个遍历器对象，对这个
    * 遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。
    *
    * 如果没有Iterator接口的对象，使用扩展运算符，将会报错。
    */
    {
        const obj = {a:1,b:2}
       // console.log(...obj);
    }
    </script>

    <span class = "name">1111</span>
    <span class = "name">2222</span>
    <span class = "name">3333</span>
    <span class = "name">4444</span>
    <span class = "name">5555</span>
    <span>6666</span>
    <span>7777</span>
    <span>8888</span>
    <script>
        /**
        * 2、Array.from()
        * Array.from方法用于将两类对象转为真正的数组，类似数组的对象（array-like object）
        * 和 可遍历(iteratable)的对象（包括ES6新增的数据结构的Set 和 Map）
        *
        * 下面是一个类似数组的对象，Array.from将它转为真正的数组。
        */
        {
            let arrayLike = {
                '0' : 'a',
                '1' : 'b',
                '2' : 'c',
                length: 3
            }
            // ES6 
            let arr1 = Array.from(arrayLike);

            // ES5
            let arr2 = [].slice.call(arrayLike);
            console.log(arr1,arr2);
        }
        /**
        * 实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部
        * 的arguments对象，Array.from 都可以将他们转为真正的数组。
        */
        {   
            // NodeList对象
            let oDiv = document.querySelectorAll('div');
            Array.from(oDiv).filter(item => {
                console.log(item.textContent.length);
            })

            // arguments 对象
            function foo() {
                var args = Array.from(arguments);
            }
        }
        /**
        * 上面代码中,querySelectorAll方法返回的是一个类似数组的对象，可以将这个对象
        * 转为真正的数组，在使用filter方法
        *
        * 只要是部署了Iterator接口的数据结构，Array.from都能将其转为数组
        */
        {
            console.log(Array.from('hello'));

            let nameSet = new Set(['a','b']);
            console.log(Array.from(nameSet));

            let map = new Map([
                [1,'one'],[2,'two'],[3,'three']
            ])
            console.log(Array.from(map.keys()));
        }
        /**
        * 上面代码中，字符串和Set结构都具有Iterator接口，因此可以被Array.from转为
        * 真正的数组
        * 
        * 如果参数是一个真正的数组，Array.from会返回一个一模一样的新数组。
        */
        {
            console.log(Array.from([1,2,3]))
        }
        /**
        * 值得提醒得是，扩展运算符（...）也可以将某些数据结构转为数组。
        */
        {
            // arguments对象
            function foo() {
                const args = [...arguments];
            }

            // NodeList对象
            [...document.querySelectorAll('div')]
        }
        /**
         * 扩展运算符背后调用的是遍历器接口，如果一个对象没有部署这个接口，就无法
         * 转换。Array.from方法还支持类似数组的对象。所谓类似数组的对象，本质特征
         * 只有一个，即必须有length属性，因此，任何有length属性的对象，都可以通过
         * Array.from方法转为数组，而此时扩展运算符就无法转换。
        */
       {
           console.log(Array.from({length:3}));
       }
       /**
        * 上面代码中，Array.from返回了一个具有三个成员的数组，每个位置都是undefined
        * 扩展运算符转换不了这个对象。
        * 
        * 对于还没有部署该方法的浏览器，可以用Array.prototype.slice方法代替。
       */
      {
          const toArray = (() => {
              Array.from ? Array.from : obj => [].slice.call(obj)
          })
      }
      /**
       * Array.from 还可以接受第二个参数，作用类似于数组的map方法，用来对每个
       * 元素进行处理，将处理后的值放入返回的数组。
      */
     {
         let arrayLike = {
             0: 1,
             1: 4,
             2: 6,
             length: 3
         }
         console.log(Array.from(arrayLike,item => item * item));
         console.log(Array.from(arrayLike).map(item => item * item));
         console.log(Array.from([1,2,3],item => item * item));
     }
     /**
      * 下面的例子是取出一组DOM节点的文本内容。
     */
    {
        let spans = document.querySelectorAll("span.name");

        // Array.from()
        let names = Array.from(spans,s => s.textContent);
        console.log(names);

        let names1 = [...spans].map(item => item.textContent);
        console.log(names1);
    }
    </script>
</body>
</html>