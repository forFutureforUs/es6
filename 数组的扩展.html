<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <div>111</div>
    <div>222</div>
    <div>333</div>
    <script>
        /**
         * 1、 扩展运算符 
         * 含义：
         *      扩展运算符(spread)是三个点（...）.它好比rest参数的逆运算，将一个
         * 数组转为用逗号分隔的参数列。
         */    
        {
            console.log(...[1,2,3]); // 1  2  3

            console.log(1,...[2,3,4],5)  // 

            console.log(...document.querySelectorAll('div'));
        }
        // 该运算符主要用于函数调用
        {
            function push(array,...items) {
                array.push(...items);
            }
            function add(x,y) {
                return x + y;
            }
            const numbers = [4,38];
            console.log(add(...numbers));

        }
        /**
         * 上面代码中，array.push(...items)和add(...numbers)这两行，都是函数调用
         * 他们的都使用了扩展运算符，该运算符将一个数组，变为参数序列。
         * 
         * 扩展运算符与正常的函数参数可以结合使用，非常灵活。
        */
        {
            function f(v,w,x,y,z) {
                return v+w+x+y+z;
            }
            const args = [0,1];
            console.log(f(-1,...args,2,...[3]));
        }
        // 扩展运算符后面还可以放置表达式
        {
            let x = 1;
            const arr = [...(x>0? ['a']: []),'b'];
            console.log(arr);
        }
        // 如果扩展运算符后面是一个空数组，则不产生任何效果。
        {
            console.log([...[],1]);
        }
        /**
         * 替代函数的apply方法
         * 由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的
         * 参数了
        */
       {
            // ES5写法
            function f(x,y,z) {

            }
            var args = [0,1,2];
            f.apply(null,args);

            function f1(a,b,c) {

            }
            let arg = [1,2,3];
            f1(...args);
       }
       /**
        * 下面是扩展运算符取代apply方法的一个实际的例子，应用Math,max方法，简化求出
        * 一个数组最大元素的写法
       */
      {
          // ES5的写法
          Math.max.apply(null,[3,6,8,1]);
          // ES6的写法
          Math.max(...[3,6,8,1]);
          // 等同于
          Math.max(14,3,77);
      }
      /**
       * 上面代码中，由于javaScript不提供求数组最大元素的函数，所以只能套用Math.max
       * 函数，将数组转为一个参数序列，然后求最大值，有了扩展运算符以后，就可以直接
       * 使用Math.max了
      */
     {
         //ES5的写法
         let arr1 = [0,1,2];
         let arr2 = [3,4,5];
         Array.prototype.push.apply(arr1,arr2);
         console.log(arr1,arr2);

         // ES6的写法
         let arr3 = [5,6,7];
         let arr4 = [6,7,8];
         arr3.push(...arr4);
         console.log(arr3,arr4);
     }
     /**
      * 上面代码的ES5写法中，push方法的参数不能是数组，所以只能通过apply方法
      * 变通使用push方法。有了扩展运算符，就可以直接将数组传入push方法。
      * 
      * 下面是另外一个例子
     */
    {
        // ES5
        new (Date.bind.apply(Date,[null,2015,1,1]))
        // ES6
        new Date(...[2015,1,1]);
    }
    /**
     * 扩展运算符的应用
     * （1）复制数组
     * 数组是复合数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆
     * 一个全新的数组。
    */
   {
       const a1 = [1,2];
       const a2 = a1;

       a2[0] = 2;
       console.log(a1); // [2,2]
   }
   /**
    * 上面代码中，a2并不是a1的克隆，而是指向同一份数据的另一个指针。修改a2,会
    * 直接导致a1的变化。
    * 
    * ES5只能变通方法来复制数组。
   */
  {
      const a1 = [1,2];
      const a2 = a1.concat();

      a2[0] = 2;
      console.log(a1);   // [1,2];
    }
    /**
     * 上面代码中，a1会返回原数组的克隆，在修改a2就不会对a1产生影响。
     * 
     * 扩展运算符提供了复制数组简便写法。
     */
    {
        const a1 = [1,2];
        // 写法一
        const a2 = [...a1];
        // 写法二
        const [...a3] = a1;
        console.log(a2,a3);
        a1[0] = 111;
        a2[0] = 222;
        a3[0] = 333;
        console.log(a1,a2,a3);
    }
    /**
     * 上面的两种写法，a2,a3都是a1的克隆
     * （2） 合并数组
     * 扩展运算符提供了数组合并的新写法
     */
    {
        const arr1 = ['a','b'];
        const arr2 = ['c'];
        const arr3 = ['d','e'];

        // ES5的合并数组
        console.log(arr1.concat(arr2,arr3));
        console.log(arr1,arr2,arr3);

        // ES6的合并数组
        console.log(...arr1,...arr2,...arr3);
    }
    // 不过，这两种方法都是浅拷贝，使用的时候需要注意
    {
        const a1 = [{foo: 1}];
        const a2 = [{bar: 2}];

        const a3 = a1.concat(a2);
        const a4 = [...a1,...a2];

        console.log(a3[0] === a1[0]);
        console.log(a4[0] === a1[0]);
    }
    /**
     * 上面代码中，a3和a4使用两种不同方法合并而成的新数组，但是他们的成员都是对
     * 原数组的引用，这就是浅拷贝，如果修改了原数组的成员，会同步反映到新数组
     * 
     * （3） 与解构赋值结合
     * 扩展运算符可以与解构赋值结合起来，用于生成数组
    */
   {
       // ES5
        const list = [1,2,3,4,5,7,6]
       let a = list[0], rest = list.slice(1)
       // ES6
       let [b,...last] = list;
       console.log(last);
   }
   // 下面是另外一个例子
   {
       const [first,...rest] = [1,2,3,4,5,6];
       console.log(first,rest);

       const [firstone,...restone] = [];
       console.log(firstone,restone); // undefined []

       const [firsttwo,...resttwo] = ['foo'];
       console.log(firsttwo,resttwo); // foo []
   }
   // 如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错
   {
       //const [...rest,last] = [1,2,3,4,5,6];

       //const [first,...medium,last] = [1,2,3,4,5,6]
   }
   /**
    * (4) 字符串
    * 
    * 扩展运算符还可以将字符串转为真正的数组
   */
    {
        console.log([...'hello']);
        console.log('hello'.split(''));
    }
    // 上面的写法，有一个重要的好处，那就是你能够正确识别四个字节的Unicode字符
    {
        console.log('\uD83D\uDE80'.codePointAt(0).toString(16));
        console.log(String.fromCodePoint(0x1f680));
        console.log('\u{D83D}');
        console.log("\u{20BB7}");
        console.log('0x20BB7'.codePointAt(0).toString(16));
        console.log(String.fromCodePoint(0x20BB7));

    }
    </script>
</body>
</html>